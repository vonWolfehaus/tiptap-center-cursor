<template>
  <div ref="elScroller" class="scroller">
    <div class="scroll-content fh" :class="contentStyle">
      <slot />
    </div>
  </div>
</template>

<script>
export default {
  props: {
    contentStyle: {
      type: Object,
      default() {
        return {};
      },
    },
    width: {
      type: String,
      default: "8",
    },
    padding: String,
    disabled: {
      type: Boolean,
      default: false,
    },
  },

  data() {
    return {
      pad: "10px",
      sw: "8px",
      position: "absolute",
    };
  },

  methods: {
    getPosition() {
      return this.$refs.elScroller.scrollTop;
    },
    getHeight() {
      return this.$refs.elScroller.offsetHeight;
    },
    scroll(to = 0) {
      if (!to) return;
      let top = to;
      if (typeof to !== "number") {
        let rect = null;
        if (to.getBoundingClientRect) rect = to.getBoundingClientRect();
        else rect = to.$el.getBoundingClientRect();
        top = rect.top - 300;
      }
      const opts = {
        top,
        behavior: "smooth",
      };
      this.$refs.elScroller.scrollTo(opts);
    },
    scrollBy(top = 0) {
      const opts = {
        top,
        behavior: "smooth",
      };
      this.$refs.elScroller.scrollBy(opts);
    },
    scrollToTop() {
      const opts = {
        top: 0,
        behavior: "instant",
      };
      this.$refs.elScroller.scrollTo(opts);
    },
    scrollToBottom() {
      const opts = {
        top: this.$refs.elScroller.scrollHeight,
        behavior: "instant",
      };
      this.$refs.elScroller.scrollBy(opts);
    },
  },

  created() {
    if (this.padding == 0 || this.padding) this.pad = this.padding + "px";
    if (this.width) this.sw = this.width + "px";
    this.position = this.disabled ? "static" : "absolute";
  },
};
</script>

<style scoped>
.scroller {
  /* --resize-buffer-width: 6px; */
  box-sizing: border-box;
  position: v-bind("position");
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow-y: scroll;
  overflow-x: hidden;
  padding: v-bind(pad);
  transition: all 400ms ease;
}

.scroller::-webkit-scrollbar {
  width: v-bind(sw);
}

.scroller::-webkit-scrollbar-thumb {
  border-radius: calc(v-bind(sw) * 0.5);
  background-color: rgba(255, 255, 255, 0.2);
}

.scroller::-webkit-scrollbar-thumb:hover {
  background-color: rgba(255, 255, 255, 0.3);
}

.scroll-content {
  width: calc(100% + v-bind(sw));
}
</style>




















































<template>
  <div class="center tiptap fh">
    <BubbleMenu
      v-if="editor"
      :editor="editor"
      :tippy-options="{ duration: 100 }"
    >
      <button
        @click="editor.chain().focus().setTextAlign('left').run()"
        :class="{ 'is-active': editor.isActive({ textAlign: 'left' }) }"
      >
        left
      </button>
      <button
        @click="editor.chain().focus().setTextAlign('center').run()"
        :class="{ 'is-active': editor.isActive({ textAlign: 'center' }) }"
      >
        center
      </button>
      <button
        @click="editor.chain().focus().setTextAlign('right').run()"
        :class="{ 'is-active': editor.isActive({ textAlign: 'right' }) }"
      >
        right
      </button>
      <button
        @click="editor.chain().focus().setTextAlign('justify').run()"
        :class="{ 'is-active': editor.isActive({ textAlign: 'justify' }) }"
      >
        justify
      </button>

      <br />

      <button
        @click="editor.chain().focus().toggleBold().run()"
        :class="{ 'is-active': editor.isActive('bold') }"
      >
        <strong>B</strong>
      </button>
      <button
        @click="editor.chain().focus().toggleItalic().run()"
        :class="{ 'is-active': editor.isActive('italic') }"
      >
        <i>i</i>
      </button>
      <button
        @click="editor.chain().focus().toggleStrike().run()"
        :class="{ 'is-active': editor.isActive('strike') }"
      >
        <s>S</s>
      </button>
      <button
        @click="editor.chain().focus().toggleUnderline().run()"
        :class="{ 'is-active': editor.isActive('underline') }"
      >
        <u>u</u>
      </button>
      <button
        @click="editor.chain().focus().toggleHeading({ level: 2 }).run()"
        :class="{ 'is-active': editor.isActive('heading', { level: 2 }) }"
      >
        H2
      </button>
      <button
        @click="editor.chain().focus().toggleHeading({ level: 3 }).run()"
        :class="{ 'is-active': editor.isActive('heading', { level: 3 }) }"
      >
        H3
      </button>

      <br />

      <button
        @click="editor.chain().focus().toggleBulletList().run()"
        :class="{ 'is-active': editor.isActive('bulletList') }"
      >
        bullet
      </button>
      <button
        @click="editor.chain().focus().toggleOrderedList().run()"
        :class="{ 'is-active': editor.isActive('orderedList') }"
      >
        ordered
      </button>
    </BubbleMenu>

    <div class="content-container fh">
      <scroller
        padding="0"
        class="fh fw"
        style="padding: 0px 32px"
        ref="scroller"
      >
        <EditorContent :editor="editor" class="editor fh" />
      </scroller>
    </div>
  </div>
</template>

<script setup>
import exampleContent from "./assets/example-content.json";
import { ref, onMounted, onBeforeUnmount } from "vue";
import { BubbleMenu, Editor, EditorContent } from "@tiptap/vue-3";
import StarterKit from "@tiptap/starter-kit";
import CharacterCount from "@tiptap/extension-character-count";
import Typography from "@tiptap/extension-typography";
import TextAlign from "@tiptap/extension-text-align";
import Underline from "@tiptap/extension-underline";
import Table from "@tiptap/extension-table";
import TableCell from "@tiptap/extension-table-cell";
import TableHeader from "@tiptap/extension-table-header";
import TableRow from "@tiptap/extension-table-row";
import Image from "@tiptap/extension-image";
import Scroller from "./Scroller.vue";

let startContent = JSON.parse(JSON.stringify(exampleContent));

const editor = new Editor({
  content: startContent,
  editable: true,
  injectCSS: false,
  extensions: [
    Underline,
    CharacterCount,
    StarterKit.configure({
      heading: {
        levels: [1, 2, 3],
      },
    }),
    Typography.configure({}),
    TextAlign.configure({
      types: ["heading", "paragraph", "blockquote"],
    }),
    Table.configure({
      resizable: true,
    }),
    TableRow,
    TableHeader,
    TableCell,
    Image.configure({
      allowBase64: true,
    }),
  ],
});

const scroller = ref(null);

onMounted(() => {
  // Watch for editor content updates
  editor.on("update", () => {
    centerCursor();
  });

  // Listen to keydown events
  document.addEventListener("keydown", handleArrowKeys);

  // Function to handle key presses for up and down arrow keys
  function handleArrowKeys(event) {
    if (
      ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)
    ) {
      setTimeout(() => {
        centerCursor();
      }, 0); // Delay to allow the cursor to move before adjusting scroll
    }
  }

  // Center cursor in the middle of the visible editor area
  function centerCursor() {
    const editorElement = document.querySelector(".ProseMirror");
    const cursorPos = editor.view.state.selection.$anchor.pos;
    const cursorCoords = editor.view.coordsAtPos(cursorPos);
    const halfEditorHeight = editorElement.clientHeight / 2;

    // Get the top position of the cursor
    const cursorTop = cursorCoords.top;

    // Calculate the scroll adjustment to center the cursor
    const scrollAdjustment = cursorTop - halfEditorHeight;

    // Scroll the editor content to ensure the cursor stays in the center
    if (Math.abs(scrollAdjustment) > 5) {
      // Adding a small threshold to avoid unnecessary scrolling
      scroller.value.scrollBy(scrollAdjustment);
    }
  }

  onBeforeUnmount(() => {
    document.removeEventListener("keydown", handleArrowKeys);
  });

  // Initial scroll to center the cursor
  centerCursor();
});
</script>

<style lang="scss">
.word-count {
  margin: 10px 0;
}

.tableWrapper {
  padding: 1rem 0;
  overflow-x: auto;
}

.resize-cursor {
  cursor: ew-resize;
  cursor: col-resize;
}

.editor-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 12px;
  box-sizing: border-box;
}

.editor,
.tiptap {
  position: relative;
  display: flex;
  flex-direction: column;
  flex: 1;
  width: 100%;
  margin: 0 auto;
}

.tiptap {
  box-sizing: border-box;
  border-radius: 4px;
  padding: 4px;
}

.ProseMirror {
  flex: 1;
  min-height: 100px;
  line-height: 1.4;
  padding: 18px 0;
}

.ProseMirror p {
  text-align: left;
  font-size: 1rem;
  line-height: 1.2;
  margin-block-start: 0;
  margin-block-end: 0;
}

button.is-active {
  background-color: rgb(51, 52, 53) !important;
}

.dl-btn {
  margin-top: 10px;
}

.content-container {
  position: relative;
  width: 50%;
  border: 2px solid gray;
  border-radius: 8px;
  transition: border-color 250ms;
}

.tiptap {
  table {
    border-collapse: collapse;
    table-layout: fixed;
    width: 100%;
    margin: 0;
    overflow: hidden;

    td,
    th {
      min-width: 1em;
      border: 2px solid #ced4da;
      padding: 3px 5px;
      vertical-align: top;
      box-sizing: border-box;
      position: relative;

      > * {
        margin-bottom: 0;
      }
    }

    th {
      font-weight: bold;
      text-align: left;
      background-color: #f1f3f5;
    }

    .selectedCell:after {
      z-index: 2;
      position: absolute;
      content: "";
      left: 0;
      right: 0;
      top: 0;
      bottom: 0;
      background: rgba(200, 200, 255, 0.4);
      pointer-events: none;
    }

    .column-resize-handle {
      position: absolute;
      right: -2px;
      top: 0;
      bottom: -2px;
      width: 4px;
      background-color: #adf;
      pointer-events: none;
    }

    p {
      margin: 0;
    }
  }
}

.tableWrapper {
  padding: 1rem 0;
  overflow-x: auto;
}

.resize-cursor {
  cursor: ew-resize;
  cursor: col-resize;
}
</style>

<style lang="sass" scoped>
.center
 display: flex
 align-items: center
</style>























































function centerCursor() {
  const editorElement = document.querySelector(".ProseMirror");

  // Check if editorElement exists to avoid null errors
  if (!editorElement) {
    console.log("Editor element not found. Skipping center cursor.");
    return;
  }

  const cursorPos = editor.view.state.selection.$anchor.pos; // Current cursor position
  const docSize = editor.state.doc.content.size; // Total document size (length of content)
  const buffer = 100; // How close to the end of the document before adding padding (you can tweak this)

  // Get the cursor position relative to the document size
  const isCursorNearEnd = docSize - cursorPos + 1 < buffer; // Check if the cursor is close to the end of the document

  console.log("Current cursor position:", cursorPos);
  console.log("Total document size:", docSize);
  console.log("Cursor is near the end:", isCursorNearEnd);

  // Get the height of the editor container and calculate half its height
  const halfEditorHeight = editorElement.clientHeight / 2;

  // Add padding if cursor is near the end of the document
  if (isCursorNearEnd) {
    console.log("Cursor near the bottom, adding padding.");
    editorElement.style.paddingBottom = `${halfEditorHeight}px`; // Set the padding to half the editor height

    // Special handling to bring the last line to the center
    setTimeout(() => {
      const lastLine = editor.view.dom.lastElementChild; // Get the last element in the editor
      if (lastLine) {
        // Center the last line in the editor view
        lastLine.scrollIntoView({
          block: "center", // Scroll the last line to the center of the editor
          behavior: "smooth", // Smooth scrolling effect
        });
      }
    }, 0);

    return;
  } else {
    console.log("Cursor not near the bottom, resetting padding.");
    editorElement.style.paddingBottom = "0px"; // Remove extra padding if not near the end
  }

  // Optionally, center the cursor in the view
  const cursorCoords = editor.view.coordsAtPos(cursorPos);
  const halfEditorCenter = editorElement.clientHeight / 2;
  const cursorTop = cursorCoords.top;
  const scrollAdjustment = cursorTop - halfEditorCenter;

  if (Math.abs(scrollAdjustment) > 5) {
    // Adding a small threshold to avoid unnecessary scrolling
    scroller.value.scrollBy(scrollAdjustment);
  }
}
